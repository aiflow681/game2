<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>专业台球大师 - Pro Billiards Master</title>
    <style>
        /* --- 样式变量定义 --- */
        :root {
            --bg-zinc-50: #fafafa;
            --bg-zinc-100: #f4f4f5;
            --bg-zinc-200: #e4e4e7;
            --bg-zinc-300: #d4d4d8;
            --bg-zinc-400: #a1a1aa;
            --bg-zinc-500: #71717a;
            --bg-zinc-600: #52525b;
            --bg-zinc-700: #3f3f46;
            --bg-zinc-800: #27272a;
            --bg-zinc-900: #18181b;
            --bg-zinc-950: #09090b;
            --bg-green-700: #15803d;
            --bg-green-500: #22c55e;
            --bg-amber-500: #f59e0b;
        }

        /* --- 基础布局重置 --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent; /* 禁用移动端点击高亮 */
            user-select: none; /* 禁用文字选中，防止游戏干扰 */
        }

        /* --- 通用布局类 --- */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .justify-center { justify-content: center; }
        .relative { position: relative; }
        .absolute { position: absolute; }
        .h-screen { height: 100vh; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .shadow-2xl { box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
        .rounded-full { border-radius: 9999px; }
        .rounded-xl { border-radius: 0.75rem; }
        .rounded-2xl { border-radius: 1rem; }
        .transition-all { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .uppercase { text-transform: uppercase; }
        .font-bold { font-weight: 700; }
        .font-black { font-weight: 900; }

        /* --- 游戏主题外观 --- */
        .bg-app { background-color: var(--bg-zinc-50); color: var(--bg-zinc-900); }
        .dark .bg-app { background-color: var(--bg-zinc-950); color: white; }

        header {
            background: white;
            border-bottom: 1px solid var(--bg-zinc-200);
            padding: 12px 24px;
            z-index: 50;
        }
        .dark header { background: var(--bg-zinc-900); border-bottom-color: var(--bg-zinc-800); }

        /* 木纹理效果（纯CSS实现） */
        .wood-pattern {
            background-color: #3e2723;
            background-image:
                repeating-linear-gradient(90deg, transparent, transparent 50px, rgba(0,0,0,0.05) 50px, rgba(0,0,0,0.05) 100px),
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 100px 100px, 100% 20px;
        }

        canvas { touch-action: none; cursor: crosshair; }

        /* --- 响应式适配：竖屏模式 --- */
        @media (orientation: portrait) {
            #mainContent { flex-direction: column; padding-bottom: 80px; }
            #powerBarContainer {
                position: relative;
                top: auto; transform: none; left: auto;
                flex-direction: row; width: 90%; margin: 20px 0; height: 50px;
            }
            #powerBarRail { width: 100% !important; height: 16px !important; }
            #powerFill { height: 100% !important; width: 0%; left: 0; bottom: 0; }
            #actionButtonsContainer { position: fixed; bottom: 80px; width: 100%; flex-direction: row; padding: 0 20px; }
            #powerLabel { writing-mode: horizontal-tb !important; display: flex; gap: 4px; }
        }

        /* --- 具体的UI组件样式 --- */
        .score-box {
            background: var(--bg-zinc-100);
            border: 1px solid var(--bg-zinc-200);
            padding: 4px;
            display: flex;
            align-items: center;
        }
        .dark .score-box { background: var(--bg-zinc-800); border-color: var(--bg-zinc-700); }

        .player-card {
            padding: 4px 16px;
            text-align: center;
            border-radius: 12px;
        }
        .player-card.active { background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .dark .player-card.active { background: var(--bg-zinc-900); }

        .btn-toggle {
            width: 40px; height: 40px;
            border-radius: 50%;
            border: 1px solid var(--bg-zinc-200);
            background: white;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .dark .btn-toggle { background: var(--bg-zinc-900); border-color: var(--bg-zinc-700); color: white; }

        .icon { width: 24px; height: 24px; fill: currentColor; }
        .icon-sm { width: 16px; height: 16px; }
    </style>
</head>
<body class="bg-app transition-all">
    <div id="app" class="flex flex-col h-screen">

        <!-- --- 头部：标题与比分系统 --- -->
        <header class="flex items-center justify-between shadow-sm">
            <div class="flex items-center" style="gap: 12px;">
                <div class="rounded-full flex items-center justify-center shadow-lg" style="width: 40px; height: 40px; background: var(--bg-green-700); color: white;">
                    <svg class="icon-sm" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>
                </div>
                <h1 style="font-size: 1.25rem; font-weight: 800; letter-spacing: -0.025em; text-transform: uppercase;">专业台球大师</h1>
            </div>

            <!-- 比分板 -->
            <div class="flex items-center" style="gap: 16px;">
                <div class="score-box rounded-2xl">
                    <div id="p1Box" class="player-card active transition-all">
                        <p style="font-size: 10px; font-weight: 700; color: var(--bg-zinc-400);">玩家 1</p>
                        <span id="score1" class="font-black" style="font-size: 1.25rem;">00</span>
                    </div>
                    <div style="width: 1px; height: 32px; background: var(--bg-zinc-300); margin: 0 8px;"></div>
                    <div id="p2Box" class="player-card transition-all">
                        <p style="font-size: 10px; font-weight: 700; color: var(--bg-zinc-400);">玩家 2</p>
                        <span id="score2" class="font-black" style="font-size: 1.25rem; opacity: 0.6;">00</span>
                    </div>
                </div>

            </div>
        </header>

        <!-- --- 主游戏区域 --- -->
        <main id="mainContent" class="relative flex items-center justify-center h-full" style="padding: 24px;">
            <!-- 背景修饰 -->
            <div class="absolute w-full h-full wood-pattern" style="opacity: 0.15; z-index: -1;"></div>

            <!-- 球桌容器：多层嵌套模拟阴影与厚度 -->
            <div id="tableWrapper" class="relative w-full shadow-lg rounded-2xl" style="max-width: 900px; aspect-ratio: 2/1; background: rgba(120, 60, 20, 0.2); padding: 16px;">
                <div class="relative w-full h-full rounded-2xl shadow-2xl flex items-center justify-center" style="background: #3d2b1f; border-top: 8px solid rgba(255,255,255,0.1); padding: 16px;">
                    <!-- 台面边框与绿呢 -->
                    <div id="tableContainer" class="relative w-full h-full rounded-xl overflow-hidden shadow-inner" style="background: #4e6d32; border: 4px solid rgba(0,0,0,0.3);">
                        <canvas id="poolCanvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- 力度感应条 -->
            <div id="powerBarContainer" class="absolute flex flex-col items-center shadow-lg rounded-2xl transition-all" style="left: 40px; background: rgba(255,255,255,0.9); padding: 16px; gap: 12px; border: 1px solid rgba(0,0,0,0.05);">
                <svg class="icon" style="color: var(--bg-amber-500);" viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
                <div id="powerBarRail" class="relative rounded-full overflow-hidden" style="height: 200px; width: 20px; background: #eee; border: 1px solid #ddd;">
                    <div id="powerFill" class="absolute w-full transition-all" style="bottom: 0; height: 0%; background: linear-gradient(to top, #dc2626, #f59e0b, #22c55e);"></div>
                </div>
                <p id="powerLabel" class="font-black" style="font-size: 10px; color: #aaa; writing-mode: vertical-rl;">度力</p>
            </div>

            <!-- 浮动操作按钮与状态提示 -->
            <div id="actionButtonsContainer" class="absolute flex flex-col transition-all" style="right: 40px; bottom: 60px; gap: 16px;">
                <button id="resetBtn" class="flex items-center shadow-lg font-bold transition-all" style="background: rgba(255,255,255,0.9); border: none; padding: 12px 24px; border-radius: 16px; cursor: pointer; gap: 8px; font-size: 12px;">
                    <svg class="icon-sm" viewBox="0 0 24 24"><path d="M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    重新开始
                </button>

                <div id="statusBadge" class="flex items-center font-bold shadow-2xl transition-all" style="background: var(--bg-green-700); color: white; padding: 16px 32px; border-radius: 20px; gap: 12px;">
                    <svg id="statusIcon" class="icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                    <span id="statusText">等待击球</span>
                </div>
            </div>
        </main>

        <!-- --- 页脚：操作指南与当前回合 --- -->
        <footer class="flex items-center justify-between shadow-sm" style="padding: 16px 40px; background: white; border-top: 1px solid #eee;">
            <div class="flex" style="gap: 32px;">
                <div class="flex items-center" style="gap: 8px; font-size: 12px; color: #666; font-weight: 600;">
                    <svg class="icon-sm" style="opacity: 0.5;" viewBox="0 0 24 24"><path d="M9 11.24V7.5a2.5 2.5 0 015 0v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zM18.84 15.87l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v10.74l-3.43-.72c-.08-.01-.15-.02-.24-.02-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.41-.17-.77-.46-1.03z"/></svg>
                    长按: 蓄力并瞄准
                </div>
                <div class="flex items-center" style="gap: 8px; font-size: 12px; color: #666; font-weight: 600;">
                    <svg class="icon-sm" style="opacity: 0.5;" viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
                    松开: 发射击球
                </div>
            </div>

            <!-- 当前回合显示 -->
            <div id="turnText" class="flex items-center font-bold" style="background: rgba(34, 197, 94, 0.1); padding: 8px 16px; border-radius: 99px; color: var(--bg-green-700); font-size: 12px; gap: 8px;">
                <div style="width: 8px; height: 8px; background: var(--bg-green-500); border-radius: 50%; box-shadow: 0 0 8px rgba(34,197,94,0.5);"></div>
                回合: 玩家 1
            </div>
        </footer>
    </div>

    <script>
        /* --- 游戏引擎常量 --- */
        const TABLE_WIDTH = 800;   // 逻辑宽度
        const TABLE_HEIGHT = 400;  // 逻辑高度
        const BALL_RADIUS = 10;    // 球半径
        const FRICTION = 0.985;    // 滚动摩擦力（每帧速度衰减比例）
        const POCKET_RADIUS = 22;  // 袋口半径
        const MAX_POWER = 35;      // 最大发射初速度

        // 球号对应的视觉颜色
        const BALL_COLORS = {
            1: '#fbbf24', 2: '#2563eb', 3: '#dc2626', 4: '#7c3aed', 5: '#ea580c',
            6: '#059669', 7: '#991b1b', 8: '#000000', 9: '#fbbf24', 10: '#2563eb',
            11: '#dc2626', 12: '#7c3aed', 13: '#ea580c', 14: '#059669', 15: '#991b1b'
        };

        // 桌面六个袋口的坐标
        const POCKET_POSITIONS = [
            { x: 0, y: 0 }, { x: TABLE_WIDTH / 2, y: 0 }, { x: TABLE_WIDTH, y: 0 },
            { x: 0, y: TABLE_HEIGHT }, { x: TABLE_WIDTH / 2, y: TABLE_HEIGHT }, { x: TABLE_WIDTH, y: TABLE_HEIGHT }
        ];

        /* --- 游戏运行时状态 --- */
        let balls = [];             // 存储所有球对象的数组
        let isCharging = false;     // 是否正在蓄力中
        let currentPower = 0;       // 当前蓄力值 (0-100)
        let chargeDirection = 1;    // 蓄力条动画方向 (递增或递减)
        let aimVector = { x: 1, y: 0 }; // 瞄准归一化向量
        let isMoving = false;       // 当前桌面上是否有球正在移动
        let scores = { player1: 0, player2: 0 }; // 记分板（原p1/p2 → player1/player2）
        let currentTurn = 1;        // 当前回合玩家编号

        const canvas = document.getElementById('poolCanvas');
        const canvasContext = canvas.getContext('2d'); // 原ctx → canvasContext
        const powerFill = document.getElementById('powerFill');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const p1Box = document.getElementById('p1Box');
        const p2Box = document.getElementById('p2Box');
        const statusText = document.getElementById('statusText');
        const statusBadge = document.getElementById('statusBadge');
        const turnText = document.getElementById('turnText');
        const resetBtn = document.getElementById('resetBtn');

        /**
         * 初始化画布尺寸
         */
        function initCanvas() {
            canvas.width = TABLE_WIDTH;
            canvas.height = TABLE_HEIGHT;
        }

        /**
         * 初始化球组位置（母球 + 目标球三角形排列）
         */
        function initBalls() {
            balls = [];
            // 母球：位于左侧发球点
            balls.push({
                id: 0, position: { x: TABLE_WIDTH / 4, y: TABLE_HEIGHT / 2 }, velocity: { x: 0, y: 0 }, // 原pos/vel → position/velocity
                radius: BALL_RADIUS, color: '#ffffff', type: 'CUE', number: 0, inPocket: false
            });

            // 目标球：右侧三角形排列
            const startX = (TABLE_WIDTH * 3) / 4;
            const startY = TABLE_HEIGHT / 2;
            let ballCount = 1;
            for (let column = 0; column < 5; column++) { // 原col → column
                for (let row = 0; row <= column; row++) {
                    // 0.866 是 sin(60deg)，用于计算等边三角形紧密堆积的高度
                    const x = startX + column * (BALL_RADIUS * 2 * 0.866);
                    const y = startY - (column * BALL_RADIUS) + (row * BALL_RADIUS * 2);
                    let type = ballCount <= 7 ? 'SOLID' : 'STRIPE';
                    if (ballCount === 8) type = 'EIGHT';
                    balls.push({
                        id: ballCount, position: { x, y }, velocity: { x: 0, y: 0 }, // 原pos/vel → position/velocity
                        radius: BALL_RADIUS, color: BALL_COLORS[ballCount] || '#000',
                        type, number: ballCount, inPocket: false
                    });
                    ballCount++;
                }
            }
        }

        /**
         * 物理碰撞解决算法 (完全弹性碰撞)
         * 基于动量守恒和能量守恒简化后的法线投影法
         */
        function resolveCollision(ball1, ball2) { // 原b1/b2 → ball1/ball2
            if (ball1.inPocket || ball2.inPocket) return;
            const deltaX = ball2.position.x - ball1.position.x; // 原dx → deltaX
            const deltaY = ball2.position.y - ball1.position.y; // 原dy → deltaY
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // 原dist → distance

            // 距离小于直径之和则发生碰撞
            if (distance < ball1.radius + ball2.radius) {
                // 1. 计算法线向量
                const normalX = deltaX / distance; // 原nx → normalX
                const normalY = deltaY / distance; // 原ny → normalY

                // 2. 修正位置，防止球体嵌入
                const overlapDistance = (ball1.radius + ball2.radius - distance) / 2; // 原overlap → overlapDistance
                ball1.position.x -= normalX * overlapDistance;
                ball1.position.y -= normalY * overlapDistance;
                ball2.position.x += normalX * overlapDistance;
                ball2.position.y += normalY * overlapDistance;

                // 3. 计算相对速度在法向上的投影
                const velocity1Normal = ball1.velocity.x * normalX + ball1.velocity.y * normalY; // 原v1n → velocity1Normal
                const velocity2Normal = ball2.velocity.x * normalX + ball2.velocity.y * normalY; // 原v2n → velocity2Normal

                // 4. 交换法向分量（由于质量相等，碰撞表现为速度法向分量完全交换）
                ball1.velocity.x += (velocity2Normal - velocity1Normal) * normalX;
                ball1.velocity.y += (velocity2Normal - velocity1Normal) * normalY;
                ball2.velocity.x += (velocity1Normal - velocity2Normal) * normalX;
                ball2.velocity.y += (velocity1Normal - velocity2Normal) * normalY;
            }
        }

        /**
         * 物理引擎主更新循环
         */
        function update() {
            let isAnyBallMoving = false; // 原moving → isAnyBallMoving

            // 蓄力状态动态逻辑
            if (isCharging && !isMoving) {
                currentPower += 2.0 * chargeDirection;
                if (currentPower >= 100) { currentPower = 100; chargeDirection = -1; }
                if (currentPower <= 0) { currentPower = 0; chargeDirection = 1; }

                // UI力度条适配屏幕方向
                if (window.innerHeight > window.innerWidth) {
                    powerFill.style.width = `${currentPower}%`;
                    powerFill.style.height = `100%`;
                } else {
                    powerFill.style.height = `${currentPower}%`;
                    powerFill.style.width = `100%`;
                }
            }

            // 更新每个球的位置与速度
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i]; // 原b → ball
                if (ball.inPocket) continue;

                // 欧拉积分更新位移
                ball.position.x += ball.velocity.x;
                ball.position.y += ball.velocity.y;

                // 施加摩擦力衰减
                ball.velocity.x *= FRICTION;
                ball.velocity.y *= FRICTION;

                // 停止检测：速度低于阈值则强制归零，防止无限抖动
                if (Math.abs(ball.velocity.x) < 0.15) ball.velocity.x = 0;
                if (Math.abs(ball.velocity.y) < 0.15) ball.velocity.y = 0;
                if (ball.velocity.x !== 0 || ball.velocity.y !== 0) isAnyBallMoving = true;

                // 墙壁反弹逻辑 (0.8 反弹损失)
                if (ball.position.x - ball.radius < 0 || ball.position.x + ball.radius > TABLE_WIDTH) {
                    ball.velocity.x *= -0.8;
                    ball.position.x = ball.position.x - ball.radius < 0 ? ball.radius : TABLE_WIDTH - ball.radius;
                }
                if (ball.position.y - ball.radius < 0 || ball.position.y + ball.radius > TABLE_HEIGHT) {
                    ball.velocity.y *= -0.8;
                    ball.position.y = ball.position.y - ball.radius < 0 ? ball.radius : TABLE_HEIGHT - ball.radius;
                }

                // 袋口进球检测
                for (const pocket of POCKET_POSITIONS) { // 原p → pocket
                    const distanceSquared = (ball.position.x - pocket.x)**2 + (ball.position.y - pocket.y)**2; // 原distSq → distanceSquared
                    if (distanceSquared < POCKET_RADIUS * POCKET_RADIUS) {
                        ball.inPocket = true;
                        ball.velocity = { x: 0, y: 0 };
                        if (ball.type === 'CUE') {
                            // 母球进球惩罚：延迟复位
                            setTimeout(() => {
                                ball.inPocket = false;
                                ball.position = { x: TABLE_WIDTH / 4, y: TABLE_HEIGHT / 2 };
                            }, 600);
                        } else {
                            // 目标球进球：增加比分
                            if (currentTurn === 1) scores.player1++; else scores.player2++;
                            updateScoreDisplay();
                        }
                    }
                }

                // 全局碰撞检测（每对球检测一次）
                for (let j = i + 1; j < balls.length; j++) {
                    resolveCollision(ball, balls[j]);
                }
            }

            // 状态同步至UI
            if (isAnyBallMoving !== isMoving) {
                isMoving = isAnyBallMoving;
                updateStatusBadge();
            }

            draw();
            requestAnimationFrame(update);
        }

        /**
         * 渲染主函数
         */
        function draw() {
            canvasContext.clearRect(0, 0, TABLE_WIDTH, TABLE_HEIGHT);

            // 1. 绘制袋口（背景）
            canvasContext.fillStyle = '#0a0a0a';
            for (const pocket of POCKET_POSITIONS) { // 原p → pocket
                canvasContext.beginPath();
                canvasContext.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2);
                canvasContext.fill();
            }

            // 2. 绘制瞄准线与蓄力光圈
            const cueBall = balls.find(ball => ball.type === 'CUE'); // 原b → ball
            if (cueBall && !cueBall.inPocket && !isMoving) {
                canvasContext.beginPath();
                canvasContext.setLineDash([6, 4]); // 虚线
                canvasContext.strokeStyle = isCharging ? `rgba(255, 255, 255, ${0.4 + currentPower/200})` : 'rgba(255, 255, 255, 0.4)';
                canvasContext.lineWidth = 1.5 + currentPower/40;
                canvasContext.moveTo(cueBall.position.x, cueBall.position.y);
                const lineLength = 120 + currentPower;
                canvasContext.lineTo(cueBall.position.x + aimVector.x * lineLength, cueBall.position.y + aimVector.y * lineLength);
                canvasContext.stroke();
                canvasContext.setLineDash([]);

                // 环绕母球的进度光圈
                if (isCharging) {
                    canvasContext.beginPath();
                    canvasContext.arc(cueBall.position.x, cueBall.position.y, BALL_RADIUS + 6, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * currentPower) / 100);
                    canvasContext.strokeStyle = '#f59e0b';
                    canvasContext.lineWidth = 3.5;
                    canvasContext.stroke();
                }
            }

            // 3. 绘制球体
            for (const ball of balls) { // 原b → ball
                if (ball.inPocket) continue;
                canvasContext.save();

                // 落地阴影
                canvasContext.shadowBlur = 6;
                canvasContext.shadowColor = 'rgba(0,0,0,0.4)';
                canvasContext.shadowOffsetY = 3;

                // 球体主色
                canvasContext.beginPath();
                canvasContext.arc(ball.position.x, ball.position.y, ball.radius, 0, Math.PI * 2);
                canvasContext.fillStyle = ball.color;
                canvasContext.fill();

                // 模拟立体高光的径向渐变
                const gradient = canvasContext.createRadialGradient( // 原grad → gradient
                    ball.position.x - ball.radius * 0.35,
                    ball.position.y - ball.radius * 0.35,
                    ball.radius * 0.1,
                    ball.position.x,
                    ball.position.y,
                    ball.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                canvasContext.fillStyle = gradient;
                canvasContext.fill();

                // 绘制球号
                if (ball.type !== 'CUE') {
                    canvasContext.fillStyle = (ball.number === 1 || ball.number === 9) ? '#000' : '#fff';
                    canvasContext.font = 'bold 8px system-ui';
                    canvasContext.textAlign = 'center';
                    canvasContext.textBaseline = 'middle';
                    canvasContext.fillText(ball.number.toString(), ball.position.x, ball.position.y);
                }
                canvasContext.restore();
            }
        }

        /**
         * 更新比分板UI
         */
        function updateScoreDisplay() {
            score1El.textContent = scores.player1.toString().padStart(2, '0');
            score2El.textContent = scores.player2.toString().padStart(2, '0');
        }

        /**
         * 更新游戏状态徽章
         */
        function updateStatusBadge() {
            if (isMoving) {
                statusBadge.style.background = '#e4e4e7';
                statusBadge.style.color = '#71717a';
                statusText.textContent = "正在滚动";
            } else {
                statusBadge.style.background = 'var(--bg-green-700)';
                statusBadge.style.color = 'white';
                statusText.textContent = "等待击球";
            }
        }

        /**
         * 切换玩家回合
         */
        function switchTurn() {
            currentTurn = currentTurn === 1 ? 2 : 1;
            turnText.textContent = `回合: 玩家 ${currentTurn}`;
            if (currentTurn === 1) {
                p1Box.classList.add('active'); p2Box.classList.remove('active');
                score1El.style.opacity = '1'; score2El.style.opacity = '0.6';
            } else {
                p2Box.classList.add('active'); p1Box.classList.remove('active');
                score2El.style.opacity = '1'; score1El.style.opacity = '0.6';
            }
        }

        /**
         * 输入开始处理 (Mouse Down / Touch Start)
         */
        function handleInputStart(event) { // 原e → event（可选，保留e也可）
            if (isMoving) return;
            isCharging = true;
            updateAim(event);
        }

        /**
         * 输入结束处理 (Mouse Up / Touch End)
         */
        function handleInputEnd() {
            if (!isCharging) return;
            const cueBall = balls.find(ball => ball.type === 'CUE'); // 原b → ball
            if (cueBall && !cueBall.inPocket) {
                // 根据蓄力百分比计算发射力度
                const shotPower = (currentPower / 100) * MAX_POWER;
                cueBall.velocity = { x: aimVector.x * shotPower, y: aimVector.y * shotPower };
                switchTurn();
            }
            // 重置蓄力参数
            isCharging = false;
            currentPower = 0;
            chargeDirection = 1;
            powerFill.style.height = '0%';
            powerFill.style.width = '0%';
        }

        /**
         * 更新瞄准方向：计算输入点相对于母球的单位向量
         */
        function updateAim(event) { // 原e → event
            if (isMoving) return;
            const canvasRect = canvas.getBoundingClientRect(); // 原rect → canvasRect
            // 兼容触摸与鼠标坐标
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            // 重要：将屏幕坐标缩放至 Canvas 逻辑坐标
            const scaleX = TABLE_WIDTH / canvasRect.width;
            const scaleY = TABLE_HEIGHT / canvasRect.height;
            const x = (clientX - canvasRect.left) * scaleX;
            const y = (clientY - canvasRect.top) * scaleY;

            const cueBall = balls.find(ball => ball.type === 'CUE'); // 原b → ball
            if (cueBall) {
                const deltaX = x - cueBall.position.x; // 原dx → deltaX
                const deltaY = y - cueBall.position.y; // 原dy → deltaY
                const magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY); // 原mag → magnitude
                if (magnitude > 0) aimVector = { x: deltaX / magnitude, y: deltaY / magnitude };
            }
        }

        /* --- 生命周期与事件挂载 --- */
        initCanvas();
        initBalls();
        update(); // 启动渲染循环

        // 鼠标事件
        canvas.addEventListener('mousedown', handleInputStart);
        window.addEventListener('mouseup', handleInputEnd);
        canvas.addEventListener('mousemove', updateAim);

        // 触摸事件（禁用默认行为防止滚动）
        canvas.addEventListener('touchstart', (event) => {
            if (event.cancelable) event.preventDefault();
            handleInputStart(event);
        }, { passive: false });
        window.addEventListener('touchend', handleInputEnd);
        canvas.addEventListener('touchmove', (event) => {
            if (event.cancelable) event.preventDefault();
            updateAim(event);
        }, { passive: false });

        // UI交互事件
        resetBtn.addEventListener('click', () => {
            scores = { player1: 0, player2: 0 }; // 重置比分
            currentTurn = 1;
            updateScoreDisplay();
            initBalls();
            p1Box.classList.add('active'); p2Box.classList.remove('active');
            score1El.style.opacity = '1'; score2El.style.opacity = '0.6';
        });

        // 窗口尺寸适应
        window.addEventListener('resize', () => {
            if (window.innerHeight > window.innerWidth) { powerFill.style.height = '100%'; }
            else { powerFill.style.width = '100%'; }
        });
    </script>
</body>
</html>